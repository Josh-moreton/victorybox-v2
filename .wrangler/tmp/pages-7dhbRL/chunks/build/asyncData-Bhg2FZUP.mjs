import{M as a,R as e,S as t}from"./server.mjs";import{b as s,s as r,W as n,j as l,a4 as o,u as i}from"../routes/renderer.mjs";function useAsyncData(...c){var d,u,y,p,f,m,D,_,v;const g="string"==typeof c[c.length-1]?c.pop():void 0;"string"!=typeof c[0]&&c.unshift(g);let[h,P,w={}]=c;if("string"!=typeof h)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof P)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const C=a(),b=P;w.server=null==(d=w.server)||d,w.default=null!=(u=w.default)?u:()=>e.value,w.getCachedData=null!=(y=w.getCachedData)?y:()=>C.isHydrating?C.payload.data[h]:C.static.data[h],w.lazy=null!=(p=w.lazy)&&p,w.immediate=null==(f=w.immediate)||f,w.deep=null!=(m=w.deep)?m:e.deep,w.dedupe=null!=(D=w.dedupe)?D:"cancel";const hasCachedData=()=>null!=w.getCachedData(h,C);if(!C._asyncData[h]||!w.immediate){null!=(v=C.payload._errors)[h]||(v[h]=e.errorValue);const a=w.deep?s:r;C._asyncData[h]={data:a(null!=(_=w.getCachedData(h,C))?_:w.default()),pending:s(!hasCachedData()),error:n(C.payload._errors,h),status:s("idle"),_default:w.default}}const j={...C._asyncData[h]};delete j._default,j.refresh=j.execute=(a={})=>{var s,r;if(C._asyncDataPromises[h]){if("defer"===(r=null!=(s=a.dedupe)?s:w.dedupe)||!1===r)return C._asyncDataPromises[h];C._asyncDataPromises[h].cancelled=!0}if((a._initial||C.isHydrating&&!1!==a._initial)&&hasCachedData())return Promise.resolve(w.getCachedData(h,C));j.pending.value=!0,j.status.value="pending";const n=new Promise(((a,e)=>{try{a(b(C))}catch(a){e(a)}})).then((async a=>{if(n.cancelled)return C._asyncDataPromises[h];let t=a;w.transform&&(t=await w.transform(a)),w.pick&&(t=function(a,e){const t={};for(const s of e)t[s]=a[s];return t}(t,w.pick)),C.payload.data[h]=t,j.data.value=t,j.error.value=e.errorValue,j.status.value="success"})).catch((a=>{if(n.cancelled)return C._asyncDataPromises[h];j.error.value=t(a),j.data.value=i(w.default()),j.status.value="error"})).finally((()=>{n.cancelled||(j.pending.value=!1,delete C._asyncDataPromises[h])}));return C._asyncDataPromises[h]=n,C._asyncDataPromises[h]},j.clear=()=>function(a,t){t in a.payload.data&&(a.payload.data[t]=void 0);t in a.payload._errors&&(a.payload._errors[t]=e.errorValue);a._asyncData[t]&&(a._asyncData[t].data.value=void 0,a._asyncData[t].error.value=e.errorValue,a._asyncData[t].pending.value=!1,a._asyncData[t].status.value="idle");t in a._asyncDataPromises&&(a._asyncDataPromises[t]&&(a._asyncDataPromises[t].cancelled=!0),a._asyncDataPromises[t]=void 0)}(C,h);if(!1!==w.server&&C.payload.serverRendered&&w.immediate){const a=j.refresh({_initial:!0});l()?o((()=>a)):C.hook("app:created",(async()=>{await a}))}const k=Promise.resolve(C._asyncDataPromises[h]).then((()=>j));return Object.assign(k,j),k}export{useAsyncData as u};
//# sourceMappingURL=asyncData-Bhg2FZUP.mjs.map
